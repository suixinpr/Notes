# 事务管理

## 事务

通常，从数据库用户的角度来看，数据库中一些操作的集合被认为是一个独立单元。例如，从顾客的立场来看，从支票账户到储蓄账户的资金转账是一次单一的操作；而在数据库系统中，这是由几个操作组成的。这样数据库中构成单一逻辑单元的操作集合被称作**事务**。

事务具有 **ACID 特性**：

* **原子性（atomicity）**：事务的所有操作在数据库中要么全部反映出来，要么全部不反应。
* **一致性（consistency）**：隔离执行事务时（在没有其他事务并发的情况下），数据库保持一致性。
* **隔离性（isolation）**：尽管多个事务并发执行，但是每个事务都感觉不到系统中有其他事务并发的执行。
* **持久性（durability）**：一个事务成功完成后，它对数据库的改变必须是永久的，即使出现系统故障。

其中**一致性**强调的更多的事务前后数据库**状态**的一致性，如果数据库在事务执行前是一致的，那么事务执行后数据库仍将保持一致。确保单个事务的一致性是编写该事务的应用程序员的责任，完整性约束的自动检查给这项工作带来了便利。

**原子性**指的是这个事务操作本身要么全部执行要么全部不执行。如果数据库出现故障，比如停电，此时数据库将会出现**不一致状态**，我们必须保证这种不一致性在数据库中是不可见的。这就是需要原子性的原因：如果具有原子性，某个事务的所有动作要么在数据库中全部反映出来（事务已提交），要么全部不反映（事务未提交，包括数据库出现故障）。这项工作由**恢复系统**来完成，后面将会介绍。

事务的**持久性**保证一旦事务成功完成.该事务对数据库所做的所有更新就都是持久的，即使事务执行完成后出现系统故障。这项工作同样是由**恢复系统**来完成的。

对于**隔离性**，如果几个事务并发地执行，即使每个事务都能确保一致性和原子性，它们的操作会以人们所不希望的某种方式交叉执行，这也会导致不一致的状态。

### 事务的隔离性

为了保证事务的隔离性，最简单的做法是**串行地（serially）**执行事务，但是为了**提高吞吐量和资源利用率**、**减少等待时间**，数据库往往会允许多个事务并发的执行。但是当并发执行多个事务时，由于事务中操作顺序的不同，往往会引起数据一致性的复杂问题，即违背了事务的隔离性。数据库系统必须控制事务之间的交互，以防止它们破坏数据库的一致性。系统通过称为**并发控制机制（concurrency-control scheme）**的一系列机制来保证这一点。后面将研究并发控制机制，现在我们集中考虑正确的并发执行这一概念。 

我们把并发事务中 SQL 语句的执行顺序称为**调度**，它们表示指令在系统中执行的时间顺序。比如 *T~1~* 和 *T~2~* 两个事务，先执行完 *T~1~* 的全部指令再执行 *T~2~* 的全部指令（调度 1）、执行完 *T~2~* 的全部指令再执行 *T~1~* 的全部指令（调度 2）、以及 *T~1~* 的指令和 *T~2~* 的指令以某种顺序交叉执行（调度 3），分别属于不同的调度。

最简单的保证事务正确性的就是**串行调度（serial schedule）**。即不允许事务并行执行，数据库同一个时刻只有一个事务正在执行，所有事务排队，一个接着一个的串行执行。这样很明显可以保证事务的正确性，但是效率低也是显而易见的。

### 可串行化

为了提高数据库的执行效率，我们没办法让事务完全串行调度，我们需要让事务并发执行。如果存在调度 *S*，对于数据库的任何状态，其执行结果完全等价于另一个串行调度 *S'*，则称这样的调度为**可串行化调度（serializable schedule）**。因为串行化调度的结果一定是正确的，所以可串行化调度的结果也一定是正确的。相比于串行调度，可串行化调度的并发度大大的提升了，但是在并发控制中却不太能去验证一个调度是否是可串行化调度，因为我们无法去通知执行该调度和串行调度去比较它们的执行结果。所以我们需要一个更易于验证的条件去保证这个调度是可串行化的。

**冲突可串行化（conflict serializable）**就是这样的条件。首先给出**冲突（conflict）**的定义：当 *I* 与 *J* 是不同事务在相同的数据项（需要特别注意，这里的数据项不等同于一行数据，可能为一个条件范围，也可能是一张表）上的操作，并且其中至少有一个是 **write** 指令时，我们说 *I* 与 *J* 是冲突（conflict）的。 包括了 Read-Write conflict、Write-Read conflict 和 Write-Write conflict，实际上就是读写冲突和写写冲突。

当冲突发生，如果它们的顺序交换，则涉及到的事务中至少有一个的行为会改变。如果调度 *S* 可以通过一系列非冲突指令交换成 *S'*，我们称 *S* 和 *S'* 是**冲突等价**的，当 *S'* 为一个串行调度时，我们称 *S* 为一个**冲突可串行化调度（conflict serializable schedule）**。

![img](./assets/schedules.png)

冲突可串行化调度是可串行化调度的子集，它的意义在于相对于可串行化，冲突可串行化是一个更加容易验证的条件，因此更加适合作为事务并发控制的实现依据。事实上，现在隔离级别中常说的可串行化（serializable），其实是就是指冲突可串行化（conflict serializable）。

验证一个调度是否为冲突可串行化调度可以通过优先图和 Strict-2PL 来进行验证。这里先跳过。

### 隔离级别

可串行化固然会让用户感到安心，但是由于可串行化调度的验证方式往往伴随着大量的阻塞等待（比如 2PL），难以达到很高的事务并发执行性能。同时对于某些应用，保证可串行性的那些协议可能只允许极小的并发度。所以为了提供更好的并发执行性能，数据库不得不放宽调度的验证，允许更多非可串行化的调度被执行，这时我们采用较弱级别的一致性。

显然，多个并发的事务执行结果可能会不再等价于任何一种串行执行的结果，也就是说，事务不再是“隔离”的，事务之间相互产生了影响，导致结果出现了错误。从隔离的角度来看，这样的事务并发执行结果就是错误的，但却是为了提高性能不得不付出的代价。为了规范用户使用，数据库需要给用户做出保证：什么样的错误会发生，而什么样的错误不会发生，这些不同的保证，就是数据库的隔离级别。SQL 标准也允许一个事务这样规定：它可以以一种与其他事务不可串行化的方式执行。

SQL标准规定的隔离性级别如下：

- **可串行化（serializable）**：通常保证可串行化调度。然而，一些数据库系统对该隔离性级别的实现在某些情况下允许非可串行化执行。
- **可重复读（repeatable read）**：只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据。但该事务不要求与其他事务可串行化。例如：当一个事务在查找满足某些条件的数据时，它可能找到一个已提交事务插入的一些数据，但可能找不到该事务插入的其他数据。
- **已提交读（read committed）**：只允许读取已提交数据，但不要求可重复读。比如，在事务两次读取一个数据项期间，另一个事务更新了该数据并提交。
- **未提交读（read uncommitted）**：允许读取未提交数据。这是SQL允许的最低一致性级别。

以上所有隔离性级别都不允许**脏写（dirty write）**，即如果一个数据项已经被另外一个尚未提交或中止的事务写入，则不允许对该数据项执行写操作。 

## 并发控制

## 恢复系统

